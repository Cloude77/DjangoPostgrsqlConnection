#Dockerfile:


Предоставленный Dockerfile начинается с базового образа python:3.11-slim,
что указывает на то, что он будет использовать версию Python 3.11 на основе тонкого варианта образа.

Следующие строки задают переменные окружения:

PYTHONDONTWRITEBYTECODE
имеет значение 1, что запрещает Python записывать файлы байт-кода ( .pyc)
на диск. Это может помочь в сценариях, когда вы хотите сэкономить место на диске
или предотвратить непреднамеренное совместное использование файлов байт-кода.

PYTHONUNBUFFERED
установлено значение 1, которое указывает Python работать
в небуферизованном режиме. В этом режиме вывод немедленно сбрасывается
на стандартный вывод, что позволяет вести журнал в реальном времени
и взаимодействовать с приложением.

Команда WORKDIR
устанавливает рабочий каталог в /code.
Это каталог, в котором будут выполняться последующие команды.

Команда COPY
копирует файлы Pipfileи Pipfile.lock
из локального каталога в /code каталог внутри контейнера Docker.

Команда RUN
выполняет следующие инструкции внутри контейнера:

Устанавливается pipenvс помощью pip менеджера пакетов.

Затем он запускается pipenv install --system
для установки зависимостей Python, указанных в Pipfile.lock файле,
в системную среду Python. При использовании этого --system флага
зависимости устанавливаются глобально, а не в виртуальной среде.

Наконец, последняя COPY 
команда копирует все файлы из локального каталога в /codeкаталог внутри контейнера.


#Docker-compose:


Ключ version указывает версию используемого синтаксиса файла Compose,
в данном случае это «3.11».

Под servicesключом у нас определены две службы: appи db.

Для app службы:

В этом build разделе указывается конфигурация сборки для службы.
Он устанавливает контекст сборки в текущий каталог ( .)
и указывает Dockerfile для использования ( Dockerfile).

Ключ command указывает команду,
которая будет выполняться при запуске контейнера.
В этом случае он запускает команду python /code/manage.py runserver 0.0.0.0:8000,
которая запускает сервер разработки Django на 0.0.0.0:8000.
Это предполагает, что в каталоге есть проект Django /code.


Ключ volumes создает привязку монтирования,
сопоставляя текущий каталог ( .) на хост-компьютере с /codeкаталогом внутри контейнера.
Это позволяет перезагружать и разрабатывать код в реальном времени.


Ключ portsсопоставляет порт 8000 хост-компьютера с портом 8000 контейнера,
обеспечивая доступ к серверу Django, работающему внутри контейнера.


Ключ depends_onуказывает, что appслужба зависит от db службы.
Это гарантирует, что db служба запускается до app службы.


Для db службы:
Ключ image указывает образ Docker,
который будет использоваться для службы.
В данном случае используется postgres образ из Docker Hub.
Ключ environment устанавливает переменные среды для dbслужбы. 


Он устанавливает переменные POSTGRES_DB, POSTGRES_USERи POSTGRES_PASSWORD
в значения postgres, указывающие значения по умолчанию для базы данных PostgreSQL.

